// Generated file

// clang-format off
const char *g_cubemap_shader =
"const int SIDE_POSITIVE_X = 0;\n"
"const int SIDE_NEGATIVE_X = 1;\n"
"const int SIDE_POSITIVE_Y = 2;\n"
"const int SIDE_NEGATIVE_Y = 3;\n"
"const int SIDE_POSITIVE_Z = 4;\n"
"const int SIDE_NEGATIVE_Z = 5;\n"
"\n"
"vec3 cm_get_uv_from_xyz(vec3 p) {\n"
"	vec3 ap = abs(p);\n"
"	float ma;\n"
"	vec2 uv;\n"
"	int f;\n"
"\n"
"	if (ap.z >= ap.x && ap.z >= ap.y) {\n"
"		f = p.z < 0.0 ? SIDE_NEGATIVE_Z : SIDE_POSITIVE_Z;\n"
"		// Protect from NaN when sampling at (0,0,0)\n"
"		ma = 0.5 / max(ap.z, 0.0001);\n"
"		uv = vec2(p.z < 0.0 ? -p.x : p.x, -p.y);\n"
"\n"
"	} else if (ap.y >= ap.x) {\n"
"		f = p.y < 0. ? SIDE_NEGATIVE_Y : SIDE_POSITIVE_Y;\n"
"		ma = 0.5 / max(ap.y, 0.0001);\n"
"		uv = vec2(p.x, p.y < 0.f ? -p.z : p.z);\n"
"\n"
"	} else {\n"
"		f = p.x < 0.0 ? SIDE_NEGATIVE_X : SIDE_POSITIVE_X;\n"
"		ma = 0.5 / max(ap.x, 0.0001);\n"
"		uv = vec2(p.x < 0.0 ? p.z : -p.z, -p.y);\n"
"	}\n"
"\n"
"	return vec3(uv * ma + vec2(0.5), float(f));\n"
"}\n"
"\n"
"// Calculates the cubic 2D Hermite interpolation within a quad of 4 points with known derivatives\n"
"float interpolate_hermite_2d(\n"
"		const vec2 r, // Relative position within the 2x2 quad\n"
"		const vec2 d, // Distance between the points (may default to (1,1))\n"
"		// Point values and their derivatives\n"
"		// x: value, y: x-derivative, z: y-derivative\n"
"		const vec3 t00,\n"
"		const vec3 t10,\n"
"		const vec3 t01,\n"
"		const vec3 t11\n"
") {\n"
"	const float rx2 = r.x * r.x;\n"
"	const float ry2 = r.y * r.y;\n"
"	const float rx3 = rx2 * r.x;\n"
"	const float ry3 = ry2 * r.y;\n"
"\n"
"	const float a0x = 2.f * rx3 - 3.f * rx2 + 1.f;\n"
"	const float a0y = 2.f * ry3 - 3.f * ry2 + 1.f;\n"
"	const float a1x = -2.f * rx3 + 3.f * rx2;\n"
"	const float a1y = -2.f * ry3 + 3.f * ry2;\n"
"	const float b0x = d.x * (rx3 - 2.f * rx2 + r.x);\n"
"	const float b0y = d.y * (ry3 - 2.f * ry2 + r.y);\n"
"	const float b1x = d.x * (rx3 - rx2);\n"
"	const float b1y = d.y * (ry3 - ry2);\n"
"\n"
"	const float a00 = a0x * a0y;\n"
"	const float a10 = a1x * a0y;\n"
"	const float a01 = a0x * a1y;\n"
"	const float a11 = a1x * a1y;\n"
"\n"
"	const vec2 b00 = vec2(b0x * a0y, a0x * b0y);\n"
"	const vec2 b10 = vec2(b1x * a0y, a1x * b0y);\n"
"	const vec2 b01 = vec2(b0x * a1y, a0x * b1y);\n"
"	const vec2 b11 = vec2(b1x * a1y, a1x * b1y);\n"
"\n"
"	return //\n"
"			t00.x * a00 + //\n"
"			t10.x * a10 + //\n"
"			t01.x * a01 + //\n"
"			t11.x * a11 + //\n"
"			dot(t00.yz, b00) + //\n"
"			dot(t10.yz, b10) + //\n"
"			dot(t01.yz, b01) + //\n"
"			dot(t11.yz, b11);\n"
"}\n"
"\n"
"float cm_sample_hermite(sampler2DArray tex, vec3 position, vec2 derivative_decoding_params) {\n"
"	vec3 uv_norm = cm_get_uv_from_xyz(position);\n"
"	int side = int(uv_norm.z);\n"
"	vec2 uv_pixf = uv_norm.xy * vec2(textureSize(tex, 0).xy - ivec2(2)) + vec2(0.5);\n"
"	ivec2 p0 = ivec2(floor(uv_pixf));\n"
"	ivec2 p1 = p0 + ivec2(1);\n"
"	vec2 pf = uv_pixf - floor(uv_pixf);\n"
"\n"
"	vec4 c00 = texelFetch(tex, ivec3(p0.x, p0.y, side), 0);\n"
"	vec4 c10 = texelFetch(tex, ivec3(p1.x, p0.y, side), 0);\n"
"	vec4 c01 = texelFetch(tex, ivec3(p0.x, p1.y, side), 0);\n"
"	vec4 c11 = texelFetch(tex, ivec3(p1.x, p1.y, side), 0);\n"
"\n"
"	vec2 d00 = derivative_decoding_params.x * c00.gb + derivative_decoding_params.y;\n"
"	vec2 d10 = derivative_decoding_params.x * c10.gb + derivative_decoding_params.y;\n"
"	vec2 d01 = derivative_decoding_params.x * c01.gb + derivative_decoding_params.y;\n"
"	vec2 d11 = derivative_decoding_params.x * c11.gb + derivative_decoding_params.y;\n"
"\n"
"	//vec4 c = mix(mix(c00, c10, pf.x), mix(c01, c11, pf.x), pf.y);\n"
"	float c = interpolate_hermite_2d(pf, vec2(1.0),\n"
"		vec3(c00.r, d00),\n"
"		vec3(c10.r, d10),\n"
"		vec3(c01.r, d01),\n"
"		vec3(c11.r, d11)\n"
"	);\n"
"\n"
"	return c;\n"
"}\n";
// clang-format on
